## 共识算法——Paxos算法
> 解决非拜占庭错误的主要算法：Paxos,Raft<br>
 解决拜占庭错误的主要算法：PBEF(确定性算法),PoW(概率算法)

非拜占庭错误可以简单理解为在分布式系统中存在故障，但并不存在恶意节点的情况，如节点宕机。

拜占庭错误及为有节点伪造信息恶意响应的情况。

### 朴素客户端/服务器算法
该算法很简单，就是只有一个客户端和一个服务器组成，客户端每次向服务器发送一条命令

在该场景下，任何一条命令都无法保证能被正确的送达接受者手里。

### 带确认的客户端/服务器算法

 1. 客户端每次向服务端发送一条命令
 2. 服务端没收到一条命令，都会向客户端发送一条确认信息
 3. 如果客户端没有在合理的时间内收到服务端的确认信息，那么客户端会重新发送命令


在该场景下，客户端发送命令后，在没有接收到服务端的确认信息前，客户端是不会再发送新的命令的，除非超过合理地时间。一旦超过合理地时间客户端未收到服务端的确认信息，客户端就会再次向服务端重新发送该命令。

然而在该场景下不仅客户端发送的消息会丢失，服务端发送的消息也会丢失。假设服务端收到客户端命令后返回确认信息，然而确认信息在传输过程中丢失，客户端无法接收到该消息，那么客户端会重新发送之前的命令，即使该命令已经被服务端执行过了，为了避免这种情况，可以在客户端发送的命令前增加版本号来区别命令。

该算法很容易扩展到一个客户端对多个服务器的场景，一个客户端只需要将命令发送给每个服务器，该客户端在接收到每个服务器的响应之后就可以认为该命令以及被执行。

但是该模式无法处理多个客户端对多个服务器的情况，因为消息的传输是需要时间的。假设现在有两个客户端和两个服务器，客户端A和客户端B，服务器C和服务器D。两个服务器都维护同一个值x，此时两个客户端都发命令去更新x值，A的命令是x=x+1,B的命令是x=2\*x。因为消息的延迟导致C和D收到命令的顺序不一致，C先收到A的命令，再收到B的命令，此时服务器C上x的值就为x=(x+1)\*2=2\*x+2,D先收到B的命令再收到A的命令，此时服务器D上x的值就为x=2\*x+1。

因此需要保证多个服务器能按照同一顺序执行多个客户端传来的命令。


### 借助单一串行器

 1. 所有客户端都将消息发送给串行器，每次发送一条
 2. 串行器将收到的命令逐一发送给所有服务端
 3. 串行器收到一条命令对应的所有服务端的确认信息，就通知将成功的信息发送给发送这条命令的客户端

该模式很好理解，就像去餐馆点菜，每个顾客告诉服务员需要点的菜，服务员再把每个订单依次交给后厨处理，后厨所有菜都做完了就通知服务员，服务员再告诉顾客菜都上齐了。

但这种模式也存在缺陷，万一服务员没来上班，也就是串行器宕机了，那该系统也就GG了。

### 两阶段协议

  > 阶段1  

 1. 客户端向所有服务器请求锁
 
  >  阶段2

 2. 如果该客户端成功请求到了所有服务器的锁，那么该客户端可以向所有服务器发送命令，操作结束后再释放掉锁
 3. 如果该客户端没有获得锁或者已经释放了锁，则该客户端等待一段时间后重新进入阶段1

&nbsp;&nbsp;&nbsp;&nbsp;这一想法曾出现在多个领域中，也有不同的名称：
其中一个例子是**两阶段提交式协议**，典型的场景是数据库系统。<br>
&nbsp;&nbsp;&nbsp;&nbsp;但是这种场景对服务器的要求更高，一旦持有锁的客户端崩溃，使得所有服务器一直处于锁定资源的状态中，而无法继续完成操作。

### 基于票的协议

为了解决二阶段协议的不足，提出了基于票的协议。在该协议中服务器会一般会用时间戳等递增的值产生一张票，客户端会向所有服务器请求一张票，当超过半数的服务器回复了这个客户端时，该客户端会获得这张票，接着客户端需要将这张票和命令一起打包发给服务端。每台服务器会检查这张票的状态，如果这张票是这台服务器上最新的票，那么这台服务器就会保存客户端的命令，并向客户端发送一个正反馈。如果客户端收到了**超过半数**的服务器的正反馈，客户端就会告诉所有服务器执行之前的命令。

因为在该模式下，客户端并非去向每个服务器请求一个锁，而是使用一张**票**来给服务器发送消息，所以即使有客户端在获得票后宕机，其他客户端仍然不会受到影响，因为其他服务器还会生产票。

但是该算法仍然存在问题，比如有两个客户端A,B，A是第一个在超过半数的服务器上存储了命令C的客户端，但是A的速度很慢，当A告诉所有服务器执行命令C的过程中，另一台客户端B将部分服务器上的命令修改成了D，然后所有服务器收到了A的消息，结果一部分服务器执行了命了C，一部分消息执行了命令D。

为了解决这一问题，服务器在发布票时同时发布它当前存储的命令，这样客户端B就可以知道客户端A已经存储了C命令，可以不要求服务器存储D命令，而是继续存储C命令，这样两个客户端都尝试存储和执行相同的命令，保证了先后执行的顺序。



### Paxos算法
Paxos算法基本原理是将所有节点分成三个角色，Proposer(提案者),Acceptor(接受者),Learner(学习者)

- 提案者：负责提案，等待大家结果，每个提案都拥有一个序列号（一般是时间戳），一般由客户端扮演
- 接受者：负责投票通过提案，一般由服务端扮演
- 学习者：负责传播提案结果，可能为客户端和服务端

该算法需要满足Safety和Liveness两大约束

- Safety约束：保证投票结果的正确性：1、只有Proposer能投票。2、一次执行只产生一个决议（被接受最多的提案为决议）
- Liveness约束：保证投票过程能在一定时间内完成

算法:

	客户端（提案者）											服务器（接受者）
	
	初始化阶段..............................................................			

	c     	 //等待执行的命令									
	t=时间戳  //票号   
